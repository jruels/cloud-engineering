## Running Ansible on Terraform VMs

This lab continues from where lab 10 left off. 



In order to let Ansible manage our newly created instances, we’ll have to create an inventory file that Ansible can use. In this inventory file, there’ll be an entry for each host.

Log into Cloud9, and enter the working directory

```bash
cd $HOME/environment/tf-ansible1
```



First, we’ll create a `hosts.tpl` template file. Terraform will use this file to create the inventory file.

```ini
[web]
${instance_name}
```

Once we have the template file, we can return to our `main.tf` file and start using the [template_file](https://registry.terraform.io/providers/hashicorp/template/latest/docs/data-sources/file) data source. In this data source, we’ll define a template (our `hosts.tpl` template file) and variables that will fill the inventory file. For this variable, I’m using a `join` which joins the public IP of the EC2 instances with the Ansible inventory arguments. Once the variables are set in the template, we can output the rendered template into a file that Ansible can use. For that, I’m using the [local_file](https://registry.terraform.io/providers/hashicorp/local/latest/docs/data-sources/file) resource in Terraform.

```tf
data "template_file" "hosts" {
    template = file("./hosts.tpl")
    vars = {
        instance_name = join(" ansible_user=ubuntu ansible_ssh_private_key_file=~/.ssh/id_rsa ansible_ssh_common_args='-o StrictHostKeyChecking=no'\n", concat(aws_instance.tfansible.*.public_ip, [""]))
    }
}

resource "local_file" "hosts_file" {
    content  = data.template_file.hosts.rendered
    filename = "tf-inventory"
}
```

**Execute Terraform to create the inventory file**. 

## Creating an Ansible playbook

As an example, create `install-nginx.yaml` to install a simple web server with a webpage on each EC2 instance. This playbook installs NGINX nginx and makes sure the `/var/www/html` directory is empty. Once that’s done it creates an `index.html` file which says ‘Hello World!’ and prints the public IP address of the instance.

```yaml
---

- name: Deploy webserver
  hosts: web
  become: yes
  tasks:
    - name: Update repositories cache and install nginx
      apt:
        name: nginx
        update_cache: yes
    - name: Remove /var/www/html directory
      file:
        path: "/var/www/html"
        state: absent
    - name: Recreate /var/www/html directory
      file:
        path: "/var/www/html"
        state: directory
    - name: Create index file
      file: 
        path: "/var/www/html/index.html"
        state: touch
    - name: Put "Hello World!" in index.html
      shell: echo "<h1>Hello World!</h1><br>" >> /var/www/html/index.html
    - name: Put public ip in index.html
      shell: curl http://169.254.169.254/latest/meta-data/public-ipv4 >> /var/www/html/index.html
```

Execute ansible on the inventory generated by Terraform. 

```bash
ansible-playbook -i tf-inventory install-nginx.yaml
```



## Adding Security enhancements

In the previous lab the `main.tf` included the public key directly. Update the playbook so a `tfvar` file is used. This will be more secure and make the configuration more portable. 



Declare the variable in `variables.tf`

```json
variable "public_key" {
}
```



Update the `main.tf`

```json
resource "aws_key_pair" "keypair" {
    key_name    = "TerraformAnsible-Keypair"
    public_key  = var.public_key
}
```

Create the `terraform.tfvars` file with the `public_key` value.

```json
public_key = <your public SSH key>
```



Previously we ran Terraform and then manually ran Ansible. Now let's update our `main.tf` so it runs Ansible against the hosts created by Terraform automatically. 

Add a couple of provisioners under the `aws_instance.tfansible` resource

```
provisioner "remote-exec" {
    inline = ["sudo apt update", "sudo apt install python3 -y", "echo Done!"]

    connection {
      host        = self.public_ip
      type        = "ssh"
      user        = "ubuntu"
      private_key = file(var.private_key_path)
    }
  }

  provisioner "local-exec" {
    command = "ANSIBLE_HOST_KEY_CHECKING=False ansible-playbook -u ubuntu -i ${var.ansible_inventory} --private-key ${var.private_key_path} install-nginx.yaml"
}

```



Update `variables.tf` with a variable for your ansible inventory, and ansible playbook

```json
variable "ansible_inventory" {
}

variable "ansible_playbook" {
}
```

Update `terraform.tfvars` with the above variables.

```
ansible_inventory = "tf-inventory"
ansible_playbook = "install-nginx.yaml"
```

Execute `terraform apply`

You may see an error stating `skipping: no hosts matched` or `No changes. Your infrastructure matches the configuration.`

There is still one thing we have to resolve. The dependency between the `data` resource and our `aws_instance` resource. 

Update the `main.tf`, and remove the `local-exec` from the `aws_instance.tfansible` and add it under a `null_resource` for the ansible playbook command. 

```json
resource "null_resource" "ansible-inventory" {
  depends_on = [data.template_file.hosts, local_file.hosts_file]
  provisioner "local-exec" {
    command = "ANSIBLE_HOST_KEY_CHECKING=False ansible-playbook -u ubuntu -i ${var.ansible_inventory} --private-key ${var.private_key_path} ${var.ansible_playbook}"
  }
}
```

Run `terraform apply` to confirm it works as expected.



# Cleanup 

Execute `terraform destroy -auto-approve` to destroy the resources. 
